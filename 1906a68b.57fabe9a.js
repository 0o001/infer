(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{126:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return c})),a.d(t,"rightToc",(function(){return i})),a.d(t,"Math",(function(){return l})),a.d(t,"metadata",(function(){return s})),a.d(t,"default",(function(){return d}));var o=a(1),n=a(9),r=(a(0),a(174)),c={id:"separation-logic-and-bi-abduction",title:"Separation logic and bi-abduction"},i=[{value:"Separation logic",id:"separation-logic",children:[]},{value:"Bi-abduction",id:"bi-abduction",children:[]},{value:"Technical papers",id:"technical-papers",children:[]}],l=function(e){var t=e.code;return Object(r.b)("img",{src:"https://math.now.sh?from="+encodeURIComponent(t)+"&color=mediumslateblue",style:{height:"100%",verticalAlign:"middle"}})},s={id:"separation-logic-and-bi-abduction",title:"Separation logic and bi-abduction",description:"export const Math = ({ code }) => (",source:"@site/docs/02-separation-logic-and-biabduction.md",permalink:"/docs/separation-logic-and-bi-abduction",sidebar:"docs",previous:{title:"About Infer",permalink:"/docs/about-Infer"},next:{title:"Limitations, etc",permalink:"/docs/limitations"}},b={rightToc:i,Math:l,metadata:s},p="wrapper";function d(e){var t=e.components,a=Object(n.a)(e,["components"]);return Object(r.b)(p,Object(o.a)({},b,a,{components:t,mdxType:"MDXLayout"}),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(o.a)({parentName:"li"},{href:"separation-logic-and-bi-abduction#separation-logic"}),"Separation logic")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(o.a)({parentName:"li"},{href:"separation-logic-and-bi-abduction#bi-abduction"}),"Bi-abduction")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(o.a)({parentName:"li"},{href:"separation-logic-and-bi-abduction#technical-papers"}),"Technical papers"))),Object(r.b)("h2",{id:"separation-logic"},"Separation logic"),Object(r.b)("p",null,"Separation logic is a novel kind of mathematical logic which facilitates reasoning about\nmutations to computer memory. It enables scalability by breaking reasoning into chunks\ncorresponding to local operations on memory, and then composing\nthe reasoning chunks together."),Object(r.b)("p",null,"Separation logic is based on a logical connective ",Object(r.b)(l,{code:"\\\\( * \\\\)",mdxType:"Math"})," called the ",Object(r.b)("em",{parentName:"p"},"separating conjunction"),' and pronounced "and separately". Separation logic formulae are interpreted over program allocated heaps. The logical formula'),Object(r.b)(l,{code:"\\\\( A*B \\\\)",mdxType:"Math"})," holds of a piece of program heap (a heaplet) when it can be divided into two sub-heaplets described by ",Object(r.b)(l,{code:"\\\\(A\\\\)",mdxType:"Math"})," and ",Object(r.b)(l,{code:"\\\\(B\\\\)",mdxType:"Math"}),". For example, the formula",Object(r.b)("hr",null),Object(r.b)(l,{code:"\\\\(x \\mapsto y * y \\mapsto x \\\\)",mdxType:"Math"}),Object(r.b)("hr",null),Object(r.b)("p",null,'can be read "',Object(r.b)(l,{code:"\\\\(x\\\\)",mdxType:"Math"})," points to ",Object(r.b)(l,{code:"\\\\(y\\\\)",mdxType:"Math"})," and separately ",Object(r.b)(l,{code:"\\\\(y\\\\)",mdxType:"Math"})," points to ",Object(r.b)(l,{code:"\\\\(x\\\\)",mdxType:"Math"}),'". This formula describes precisely two allocated memory cells. The first cell is allocated at the address denoted by the pointer ',Object(r.b)(l,{code:"\\\\(x\\\\)",mdxType:"Math"})," and the content of this cell is the value of ",Object(r.b)(l,{code:"\\\\(y\\\\)",mdxType:"Math"}),".\nThe second cell is allocated at the address denoted by the pointer ",Object(r.b)(l,{code:"\\\\(y\\\\)",mdxType:"Math"})," and the content of this second cell is the value of ",Object(r.b)(l,{code:"\\\\(x\\\\)",mdxType:"Math"}),". Crucially, we know that there are precisely two cells because ",Object(r.b)(l,{code:"\\\\( * \\\\)",mdxType:"Math"})," stipulates that they are separated and therefore the cells are allocated in two different parts of memory. In other words, ",Object(r.b)(l,{code:"\\\\( * \\\\)",mdxType:"Math"}),"\nsays that ",Object(r.b)(l,{code:"\\\\(x\\\\)",mdxType:"Math"})," and ",Object(r.b)(l,{code:"\\\\(y\\\\)",mdxType:"Math"})," do not hold the same value (i.e., these pointers are not aliased).\nThe heaplet partitioning defined by the formula above can visualized like so:"),Object(r.b)("p",null,Object(r.b)("img",Object(o.a)({parentName:"p"},{src:"/img/SepSplit.jpg",alt:null}))),Object(r.b)("p",null,"The important thing about separating conjunction is\nthe way that it fits together with mutation to computer memory; reasoning about program commands\ntends to work by updating ",Object(r.b)(l,{code:"\\\\(*\\\\)",mdxType:"Math"}),"-conjuncts in-place, mimicking the operational in-place update of RAM."),Object(r.b)("p",null,"Separation logic uses Hoare triples of the form ",Object(r.b)(l,{code:"\\\\( \\lbrace pre \\rbrace prog \\lbrace post \\rbrace \\\\)",mdxType:"Math"})," where ",Object(r.b)(l,{code:"\\\\(pre\\\\)",mdxType:"Math"})," is the precondition, ",Object(r.b)(l,{code:"\\\\(prog\\\\)",mdxType:"Math"})," a program part, and ",Object(r.b)(l,{code:"\\\\(post\\\\)",mdxType:"Math"}),"\nthe postcondition. Triples are abstract specifications of the behavior of the program. For example, we could take"),Object(r.b)("hr",null),Object(r.b)(l,{code:"\\\\( \\lbrace r \\mapsto open\\rbrace \\, closeResource(r)\\, \\lbrace r \\mapsto closed\\rbrace  \\;\\;\\; (spec)\\\\)",mdxType:"Math"}),Object(r.b)("hr",null),Object(r.b)("p",null,"as a specification for a method which closes a resource given to it as a parameter."),Object(r.b)("p",null,"Now, suppose we have two resources ",Object(r.b)(l,{code:"\\\\( r\\_1 \\\\)",mdxType:"Math"})," and ",Object(r.b)(l,{code:"\\\\( r\\_2 \\\\)",mdxType:"Math"}),", described by ",Object(r.b)(l,{code:"\\\\(r\\_1 \\mapsto open * r\\_2 \\mapsto open\\\\)",mdxType:"Math"}),"\nand we close the first of them. We think operationally in terms of updating the memory in place, leaving ","\\","(r_2 \\mapsto open","\\",") alone,\nas described by this triple:"),Object(r.b)("hr",null),Object(r.b)(l,{code:"\\\\( \\lbrace r\\_1 \\mapsto open * r\\_2 \\mapsto open\\rbrace  closeResource(r\\_1) \\lbrace r\\_1 \\mapsto closed * r\\_2 \\mapsto open \\rbrace \\;\\;\\; (use)\\\\)",mdxType:"Math"}),Object(r.b)("hr",null),Object(r.b)("p",null,"What we have here is the that specification (spec) described how ",Object(r.b)(l,{code:"\\\\(closeResource()\\\\)",mdxType:"Math"})," works by mentioning only one\npiece of state, what is sometimes called a small specification,\nand in (use) we use that specification to update a larger precondition in place."),Object(r.b)("p",null,"This is an instance of a general pattern.\nThere is a rule that lets you go from smaller to bigger specifications"),Object(r.b)("hr",null),Object(r.b)(l,{code:"\\\\( \\frac{\\lbrace pre \\rbrace prog \\lbrace post \\rbrace}{\\lbrace pre * frame \\rbrace prog \\lbrace post * frame \\rbrace}\\\\)",mdxType:"Math"}),Object(r.b)("hr",null),Object(r.b)("p",null,"Our passage from (spec) to (use) is obtained by taking"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)(l,{code:"\\\\(pre\\\\)",mdxType:"Math"})," to be ",Object(r.b)(l,{code:"\\\\(r\\_1 \\mapsto open\\\\)",mdxType:"Math"})),Object(r.b)("li",{parentName:"ul"},Object(r.b)(l,{code:"\\\\(post\\\\)",mdxType:"Math"})," to be ",Object(r.b)(l,{code:"\\\\(r\\_1 \\mapsto closed \\\\)",mdxType:"Math"}),", and"),Object(r.b)("li",{parentName:"ul"},Object(r.b)(l,{code:"\\\\(frame\\\\)",mdxType:"Math"})," to be ",Object(r.b)(l,{code:"\\\\(r\\_2 \\mapsto open \\\\)",mdxType:"Math"}))),Object(r.b)("p",null,"This rule is called the ",Object(r.b)("em",{parentName:"p"},"frame rule")," of separation logic. It is named after the frame problem, a classic problem in artificial intelligence.\nGenerally, the ",Object(r.b)(l,{code:"\\\\(frame\\\\)",mdxType:"Math"})," describes state that remains unchanged; the terminology comes from the analogy of\na background scene in an animation as unchanging while the objects and characters within the scene change."),Object(r.b)("p",null,"The frame rule is the key to the principle of local reasoning in separation logic: reasoning and specifications\nshould concentrate on the resources that a program accesses (the footprint), without mentioning what\ndoesn't change."),Object(r.b)("h2",{id:"bi-abduction"},"Bi-abduction"),Object(r.b)("p",null,"Bi-abduction is a form of logical inference for separation logic which automates the key ideas about local\nreasoning."),Object(r.b)("p",null,"Usually, logic works with validity or entailment statements like"),Object(r.b)("hr",null),Object(r.b)(l,{code:"\\\\(A \\vdash B\\\\)",mdxType:"Math"}),Object(r.b)("hr",null),Object(r.b)("p",null,"which says that ",Object(r.b)(l,{code:"\\\\(A\\\\)",mdxType:"Math"})," implies ",Object(r.b)(l,{code:"\\\\(B\\\\)",mdxType:"Math"}),". Infer uses an extension of this inference question in an internal\ntheorem prover while it runs over program statements.\nInfer's question"),Object(r.b)("hr",null),Object(r.b)(l,{code:"\\\\(A * ?antiframe \\vdash B * ?frame\\\\)",mdxType:"Math"}),Object(r.b)("hr",null),Object(r.b)("p",null,"is called ",Object(r.b)("em",{parentName:"p"},"bi-abduction"),". The problem here is for the theorem prover to ",Object(r.b)("i",null," discover ")," a pair of frame and antiframe formulae that make the entailment statement valid."),Object(r.b)("p",null,"Global analyses of large programs are normally computational untractable. However,\nbi-abduction allows to break the large analysis of a large program in small independent analyses of its procedures. This gives Infer the ability to scale independently of the size of the analyzed code. Moreover, by breaking the analysis in small\nindependent parts, when the full program is analyzed again because\nof a code change the analysis results of the unchanged part of the\ncode can be reused and only the code change needs to be re-analyzed. This process is called incremental analysis and it\nis very powerful when integrating a static analysis tool like infer in a development environment."),Object(r.b)("p",null,"In order to be able to decompose a global analysis in small independent analyses, let's first consider how a function\ncall is analyzed in separation logic. Assume we have the following spec for a function ",Object(r.b)(l,{code:"\\\\( f() \\\\)",mdxType:"Math"}),":"),Object(r.b)("hr",null),Object(r.b)(l,{code:"\\\\( \\lbrace pre\\_f \\rbrace \\;\\; f() \\;\\; \\lbrace post\\_f \\rbrace \\\\)",mdxType:"Math"}),Object(r.b)("hr",null),Object(r.b)("p",null,"and by analyzing the caller function, we compute that before\nthe call of ",Object(r.b)(l,{code:"\\\\( f \\\\)",mdxType:"Math"}),", the formula ",Object(r.b)(l,{code:"\\\\( CallingState \\\\)",mdxType:"Math"})," hold. Then\nto utilize the specification of ",Object(r.b)(l,{code:"\\\\( f \\\\)",mdxType:"Math"})," the following implication must holds:"),Object(r.b)("hr",null),Object(r.b)(l,{code:"\\\\( CallingState \\vdash pre\\_f  \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; (Function Call)\\\\)",mdxType:"Math"}),Object(r.b)("hr",null),Object(r.b)("p",null,"Given that,\nbi-abduction is used at procedure call sites for two reasons: to discover missing state that is needed for the above implication to hold and allow the analysis\nto proceed (the antiframe) as well as state that the procedure leaves unchanged (the frame)."),Object(r.b)("p",null,"To see how this works suppose we have some bare code"),Object(r.b)("hr",null),Object(r.b)(l,{code:"\\\\(closeResource(r1); \\, closeResource(r2)\\\\)",mdxType:"Math"}),Object(r.b)("hr",null),Object(r.b)("p",null,"but no overall specification;\nwe are going to describe how to discover a pre/post spec for it.\nConsidering the first statement and the (spec) above, the human might say: if only we had"),Object(r.b)(l,{code:"\\\\(r1 \\mapsto open\\\\)",mdxType:"Math"})," in the precondition then we could proceed. Technically, we ask a bi-abduction question",Object(r.b)("hr",null),Object(r.b)(l,{code:"\\\\(emp * ?antiframe \\vdash r1 \\mapsto open * ?frame\\\\)",mdxType:"Math"}),Object(r.b)("hr",null),Object(r.b)("p",null,"and we can fill this in easily by picking ",Object(r.b)(l,{code:"\\\\(antiframe = r1 \\mapsto open\\\\)",mdxType:"Math"})," and ",Object(r.b)(l,{code:"\\\\(frame = emp\\\\)",mdxType:"Math"}),",\nwhere emp means the empty state. The emp is recording that at the start we presume nothing. So we obtain the trivially true implication:"),Object(r.b)("hr",null),Object(r.b)(l,{code:"\\\\(emp * r1 \\mapsto open \\vdash r1 \\mapsto open * emp\\\\)",mdxType:"Math"}),Object(r.b)("hr",null),Object(r.b)("p",null,"which, by applying logical rules, can be re-written equivalently to:"),Object(r.b)("hr",null),Object(r.b)(l,{code:"\\\\(r1 \\mapsto open \\vdash r1 \\mapsto open\\\\)",mdxType:"Math"}),Object(r.b)("hr",null),Object(r.b)("p",null,"Notice that this satisfy the (Function Call) requirement to correctly make the call.\nSo let's add that information in the pre, and while we are at it\nrecord the information in the post of the first statement that comes from (spec)."),Object(r.b)("hr",null),Object(r.b)(l,{code:"\\\\( \\lbrace r1 \\mapsto open  \\rbrace \\\\)",mdxType:"Math"}),Object(r.b)(l,{code:"\\\\( closeResource(r1) \\\\)",mdxType:"Math"}),Object(r.b)(l,{code:"\\\\( \\lbrace r1 \\mapsto closed \\rbrace \\\\)",mdxType:"Math"}),Object(r.b)(l,{code:"\\\\( closeResource(r2) \\\\)",mdxType:"Math"}),Object(r.b)("hr",null),Object(r.b)("p",null,"Now, let's move to the second statement. Its precondition ",Object(r.b)(l,{code:"\\\\(r1 \\mapsto closed\\\\)",mdxType:"Math"})," in the partial symbolic execution trace just given\ndoes not have the information needed by ",Object(r.b)(l,{code:"\\\\(closeResource(r2)\\\\)",mdxType:"Math"}),", so we can fill that in and continue by\nputting ",Object(r.b)(l,{code:"\\\\(r2 \\mapsto open\\\\)",mdxType:"Math"})," in the pre. While we are at it we can thread this assertion back to the beginning."),Object(r.b)("hr",null),Object(r.b)(l,{code:"\\\\( \\lbrace r1 \\mapsto open * r2 \\mapsto open  \\rbrace \\\\)",mdxType:"Math"}),Object(r.b)(l,{code:"\\\\( closeResource(r1) \\\\)",mdxType:"Math"}),Object(r.b)(l,{code:"\\\\( \\lbrace r1 \\mapsto closed * r2 \\mapsto open\\rbrace \\\\)",mdxType:"Math"}),Object(r.b)(l,{code:"\\\\( closeResource(r2) \\\\)",mdxType:"Math"}),Object(r.b)("hr",null),Object(r.b)("p",null,"This information on what to thread backwards can be obtained as the antiframe part of the bi-abduction question"),Object(r.b)("hr",null),Object(r.b)(l,{code:"\\\\(r1 \\mapsto closed * ?antiframe \\vdash r2 \\mapsto open * ?frame\\\\)",mdxType:"Math"}),Object(r.b)("hr",null),Object(r.b)("p",null,"where the solution picks"),Object(r.b)(l,{code:"\\\\(antiframe = r2 \\mapsto open\\\\) and \\\\(frame = r1 \\mapsto closed\\\\)",mdxType:"Math"}),". Note that the antiframe is precisely the information missing from the precondition in order for ",Object(r.b)(l,{code:"\\\\(closeResource(r2)\\\\)",mdxType:"Math"})," to proceed. On the other hand, the frame ",Object(r.b)(l,{code:"\\\\(r1 \\mapsto closed\\\\)",mdxType:"Math"})," is the portion of state not changed by ",Object(r.b)(l,{code:"\\\\(closeResource(r2)\\\\)",mdxType:"Math"}),"; we can thread that through to the overall postconditon (as justified by the frame rule), giving us",Object(r.b)("hr",null),Object(r.b)(l,{code:"\\\\( \\lbrace r1 \\mapsto open * r2 \\mapsto open  \\rbrace \\\\)",mdxType:"Math"}),Object(r.b)(l,{code:"\\\\( closeResource(r1) \\\\)",mdxType:"Math"}),Object(r.b)(l,{code:"\\\\( \\lbrace r1 \\mapsto closed * r2 \\mapsto open\\rbrace \\\\)",mdxType:"Math"}),Object(r.b)(l,{code:"\\\\( closeResource(r2) \\\\)",mdxType:"Math"}),Object(r.b)(l,{code:"\\\\( \\lbrace r1 \\mapsto closed * r2 \\mapsto closed \\rbrace\\\\)",mdxType:"Math"}),Object(r.b)("hr",null),Object(r.b)("p",null,"Thus, we have obtained a pre and post for this code by symbolically executing it, using bi-abduction\nto discover preconditions (abduction of antiframes) as well as untouched portions of memory (frames) as we go along."),Object(r.b)("p",null,"In general, bi-abduction\nprovides a way to infer a pre/post specs from bare code, as long as we know specs for the primitives at the base level of the code. The human does not need to write preconditions and postconditions for all the procedures,\nwhich is the key to having a high level of automation.\nThis is the basis for how Infer works, why it can scale, and how it can analyze code changes incrementally."),Object(r.b)("p",null,"Context: The logical terminology we have been using here comes from AI and philosophy of science.\nAbductive inference was introduced by the philosopher Charles Peirce, and described as the mechanism\nunderpinning hypothesis formation (or, guessing what might be true about the world), the most\ncreative part of the scientific process.\nAbduction and the frame problem have both attracted significant attention in AI.\nInfer uses an automated form of abduction to generate\npreconditions describing the memory that a program touches (the antiframe part above), and frame inference to\ndiscover what isn't touched.\nInfer then uses deductive reasoning to\ncalculate a formula describing the effect of a program, starting from the preconditions.\nIn a sense, Infer approaches automated reasoning about programs by mimicking what a human might do when trying to understand a program: it abduces what the program needs, and deduces conclusions of that.\nIt is when the reasoning goes wrong that Infer reports a potential bug."),Object(r.b)("p",null,"This description is by necessity simplified compared to what Infer actually does.\nMore technical information can be found in the following papers. The descriptions in the papers are\nprecise, but still simplified; there are many engineering decisions not recorded there. Finally, beyond the papers,\nyou can read the source code if you wish!"),Object(r.b)("h2",{id:"technical-papers"},"Technical papers"),Object(r.b)("p",null,"The following papers contain some of the technical background on Infer and information on how it is used inside Facebook."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{href:"http://link.springer.com/chapter/10.1007%2F3-540-44802-0_1"},"Local Reasoning about Programs that Alter Data Structures.")," An early separation logic paper which advanced ideas about local reasoning and the frame rule."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{href:"http://link.springer.com/chapter/10.1007/11804192_6"},"Smallfoot: Modular Automatic Assertion Checking with Separation Logic.")," First separation logic verification tool, introduced frame inference"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{href:"http://link.springer.com/chapter/10.1007%2F11691372_19"},"A Local Shape Analysis Based on Separation Logic.")," Separation logic meets abstract interpretation; calculating loop invariants via a fixed-point computation."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{href:"http://dl.acm.org/citation.cfm?id=2049700"},"Compositional Shape Analysis by Means of Bi-Abduction."),"The bi-abduction paper."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{href:"https://research.facebook.com/publications/moving-fast-with-software-verification/"},"Moving Fast with Software Verification.")," A paper about the way we use Infer at Facebook.")))}d.isMDXComponent=!0},174:function(e,t,a){"use strict";a.d(t,"a",(function(){return i})),a.d(t,"b",(function(){return p}));var o=a(0),n=a.n(o),r=n.a.createContext({}),c=function(e){var t=n.a.useContext(r),a=t;return e&&(a="function"==typeof e?e(t):Object.assign({},t,e)),a},i=function(e){var t=c(e.components);return n.a.createElement(r.Provider,{value:t},e.children)};var l="mdxType",s={inlineCode:"code",wrapper:function(e){var t=e.children;return n.a.createElement(n.a.Fragment,{},t)}},b=Object(o.forwardRef)((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,l=function(e,t){var a={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&-1===t.indexOf(o)&&(a[o]=e[o]);return a}(e,["components","mdxType","originalType","parentName"]),b=c(a),p=o,d=b[i+"."+p]||b[p]||s[p]||r;return a?n.a.createElement(d,Object.assign({},{ref:t},l,{components:a})):n.a.createElement(d,Object.assign({},{ref:t},l))}));function p(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,c=new Array(r);c[0]=b;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[l]="string"==typeof e?e:o,c[1]=i;for(var p=2;p<r;p++)c[p]=a[p];return n.a.createElement.apply(null,c)}return n.a.createElement.apply(null,a)}b.displayName="MDXCreateElement"}}]);