(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{147:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return l})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return d}));var a=t(1),i=t(9),r=(t(0),t(176)),o={id:"adding-models",title:"Adding models"},l={id:"adding-models",title:"Adding models",description:"## Why do we need models",source:"@site/docs/01-adding-models.md",permalink:"/docs/adding-models",sidebar:"docs",previous:{title:"Advanced usage",permalink:"/docs/advanced-features"},next:{title:"Infer Manuals",permalink:"/docs/man-pages"}},c=[{value:"Why do we need models",id:"why-do-we-need-models",children:[]},{value:"Examples of models",id:"examples-of-models",children:[{value:"Some models for C",id:"some-models-for-c",children:[]},{value:"For Java",id:"for-java",children:[]}]},{value:"How to add new models",id:"how-to-add-new-models",children:[]}],s={rightToc:c},b="wrapper";function d(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(r.b)(b,Object(a.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"why-do-we-need-models"},"Why do we need models"),Object(r.b)("p",null,"When analyzing projects with call dependencies between functions, Infer follows\nthe call graph to decide in which order to analyze these functions. The main\ngoal is to use the analysis summary of a function wherever this function is\ncalled. On the following example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c"}),"int foo(int x) {\n  if (x < 42) {\n    return x;\n  } else {\n    return 0;\n  }\n}\n\nint bar() {\n  return foo(24);\n}\n\nint baz() {\n  return foo(54);\n}\n")),Object(r.b)("p",null,"Infer starts with the analysis on ",Object(r.b)("inlineCode",{parentName:"p"},"foo")," and detect that this function either\nreturns ",Object(r.b)("inlineCode",{parentName:"p"},"0")," if the argument is greater than or equal to ",Object(r.b)("inlineCode",{parentName:"p"},"42"),", or returns the\nvalue of the argument otherwise. With this information, Infer detects that ",Object(r.b)("inlineCode",{parentName:"p"},"bar"),"\nalways returns ",Object(r.b)("inlineCode",{parentName:"p"},"24")," and ",Object(r.b)("inlineCode",{parentName:"p"},"baz")," always returns ",Object(r.b)("inlineCode",{parentName:"p"},"0"),"."),Object(r.b)("p",null,"Now, it may happen that the code of some function is not available during the\nanalysis. For example, this happens when a project uses pre-compiled libraries.\nThe most typical case is the use of the standard library like in the following\nexample:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c"}),"#include <stdlib.h>\n\nint* create() {\n  int *p = malloc(sizeof(int));\n  if (p == NULL) exit(1);\n  return p;\n}\n\nvoid assign(int x, int *p) {\n  *p = x;\n}\n\nint* my_function() {\n  int *p = create();\n  assign(42, p);\n  return p;\n}\n")),Object(r.b)("p",null,"Here, Infer will start with the analysis of ",Object(r.b)("inlineCode",{parentName:"p"},"create")," but will not find the\nsource code for ",Object(r.b)("inlineCode",{parentName:"p"},"malloc"),". To deal with this situation, Infer relies on models of\nthe missing functions to proceed with the analysis. The function ",Object(r.b)("inlineCode",{parentName:"p"},"malloc")," is\ninternally modeled as either returning ",Object(r.b)("inlineCode",{parentName:"p"},"NULL"),", or returning a valid and\nallocated pointer. Similarly, the function ",Object(r.b)("inlineCode",{parentName:"p"},"exit")," is modeled as terminating the\nexecution. Using these two models, Infer detects that ",Object(r.b)("inlineCode",{parentName:"p"},"create")," always returns an\nallocated pointer and that ",Object(r.b)("inlineCode",{parentName:"p"},"my_function")," is safe."),Object(r.b)("p",null,"At this point, it is important to note that missing source code and missing\nmodels do not make the analysis fail. Missing functions are treated as having no\neffect. However, even though skipping these missing functions is fine in most\ncases, there can be cases where it affects the quality of the analysis. For\nexample, missing models can lead to incorrect bug reports."),Object(r.b)("p",null,"Consider the case of a function ",Object(r.b)("inlineCode",{parentName:"p"},"lib_exit")," having the same semantics as ",Object(r.b)("inlineCode",{parentName:"p"},"exit"),"\nbut defined in an pre-compiled library not part of the project being analyzed:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c"}),"void lib_exit(int);\n\nint* create() {\n  int *p = malloc(sizeof(int));\n  if (p == NULL) lib_exit(1);\n  return p;\n}\n")),Object(r.b)("p",null,"In this case, Infer will not be able to know that the return statement is only\npossible in the case where ",Object(r.b)("inlineCode",{parentName:"p"},"p")," is not null. When analyzing ",Object(r.b)("inlineCode",{parentName:"p"},"my_function"),", Infer\nwill consider the null case and report a null dereference error in the call to\n",Object(r.b)("inlineCode",{parentName:"p"},"assign(42, p)"),"."),Object(r.b)("p",null,"Similarly, considering a function ",Object(r.b)("inlineCode",{parentName:"p"},"lib_alloc")," equivalent to ",Object(r.b)("inlineCode",{parentName:"p"},"malloc"),", and the\nfunction ",Object(r.b)("inlineCode",{parentName:"p"},"create")," now defined as:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c"}),"int* lib_alloc(int);\n\nint* create() {\n  int *p = lib_alloc(sizeof(int));\n  return p;\n}\n")),Object(r.b)("p",null,"Then Infer will not report any null dereference in ",Object(r.b)("inlineCode",{parentName:"p"},"my_function"),"."),Object(r.b)("h2",{id:"examples-of-models"},"Examples of models"),Object(r.b)("h3",{id:"some-models-for-c"},"Some models for C"),Object(r.b)("p",null,"Adding new models is easy. The models for C can be found in\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/facebook/infer/tree/master/infer/models/c/src"}),Object(r.b)("inlineCode",{parentName:"a"},"infer/models/c/src/")),".\nThe file\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/models/c/src/libc_basic.c"}),Object(r.b)("inlineCode",{parentName:"a"},"libc_basic.c")),"\ncontains models for some of the most commonly encountered functions from the C\nstandard library. For example, the function ",Object(r.b)("inlineCode",{parentName:"p"},"xmalloc"),", which is essentially the\nsame function as ",Object(r.b)("inlineCode",{parentName:"p"},"create")," defined above, is modeled by:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c"}),"void *xmalloc(size_t size) {\n  void *ret = malloc(size);\n  INFER_EXCLUDE_CONDITION(ret == NULL);\n  return ret;\n}\n")),Object(r.b)("p",null,"The function ",Object(r.b)("inlineCode",{parentName:"p"},"xmalloc")," is modeled using ",Object(r.b)("inlineCode",{parentName:"p"},"malloc")," to create an allocated object\nand the macro ",Object(r.b)("inlineCode",{parentName:"p"},"INFER_EXCLUDE_CONDITION")," used to eliminate the case where\n",Object(r.b)("inlineCode",{parentName:"p"},"malloc")," can return null. The list of helper functions and macros for writing\nmodels can be found in\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/models/c/src/infer_builtins.c"}),Object(r.b)("inlineCode",{parentName:"a"},"infer_builtins.c")),"."),Object(r.b)("p",null,"For a slightly more complex example, ",Object(r.b)("inlineCode",{parentName:"p"},"realloc")," is modeled as:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c"}),"void *realloc(void *ptr, size_t size) {\n  if(ptr==0) { // if ptr in NULL, behave as malloc\n    return malloc(size);\n  }\n  int old_size;\n  int can_enlarge;\n  old_size = __get_array_size(ptr); // force ptr to be an array\n  can_enlarge = __infer_nondet_int(); // nondeterministically choose whether the current block can be enlarged\n  if(can_enlarge) {\n    __set_array_size(ptr, size); // enlarge the block\n    return ptr;\n  }\n  int *newblock = malloc(size);\n  if(newblock) {\n    free(ptr);\n    return newblock;\n  }\n  else { // if new allocation fails, do not free the old block\n    return newblock;\n  }\n}\n")),Object(r.b)("p",null,"This model is based on existing models for ",Object(r.b)("inlineCode",{parentName:"p"},"malloc")," and ",Object(r.b)("inlineCode",{parentName:"p"},"free")," and three helper\nfunctions:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"__get_array_size(ptr)")," which allows to manipulate with a model what Infer\nknows about the size of the allocated memory"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"__set_array_size(ptr, size)")," to modify the information about the size of the\nallocated memory"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"__infer_nondet_int()")," to create a variable which can have any possible\ninteger value")),Object(r.b)("h3",{id:"for-java"},"For Java"),Object(r.b)("p",null,"The models for Java are following the same approach and the list of helper\nfunctions is in:"),Object(r.b)("p",null,Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/models/java/src/com/facebook/infer/models/InferBuiltins.java"}),Object(r.b)("inlineCode",{parentName:"a"},"infer/models/java/src/com/facebook/infer/models/InferBuiltins.java")),"\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/models/java/src/com/facebook/infer/models/InferUndefined.java"}),Object(r.b)("inlineCode",{parentName:"a"},"infer/models/java/src/com/facebook/infer/models/InferUndefined.java"))),Object(r.b)("p",null,"For example, Infer treats Java hash maps using a recency abstraction model:\nInfer remembers the last two keys being added by ",Object(r.b)("inlineCode",{parentName:"p"},"put")," and checked by\n",Object(r.b)("inlineCode",{parentName:"p"},"containsKey"),", which can be used to make sure that no null pointer exceptions\nare coming from the fact that ",Object(r.b)("inlineCode",{parentName:"p"},"get(key)")," returns null when ",Object(r.b)("inlineCode",{parentName:"p"},"key")," is not in the\nmap. This behavior can just be implemented via a model written in Java with the\nhelp of few helper functions understood by Infer. These models can be found in:"),Object(r.b)("p",null,Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/models/java/src/java/util/HashMap.java"}),Object(r.b)("inlineCode",{parentName:"a"},"infer/models/java/src/java/util/HashMap.java"))),Object(r.b)("p",null,"and just rely on these two methods:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"InferUndefined.boolean_undefined()")," to create a non-deterministic choice"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"(V)InferUndefined.object_undefined()")," to create a non null undefined object\nof type ",Object(r.b)("inlineCode",{parentName:"li"},"V"))),Object(r.b)("h2",{id:"how-to-add-new-models"},"How to add new models"),Object(r.b)("p",null,"Let's look at a toy example in Java. As explained above, models for C,\nObjective-C and Java are all following the same approach."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"import lib.Server;\n\npublic class Test {\n\n  enum Status {\n    SUCCESS, FAILURE, PING_FAILURE, CONNECTION_FAILURE\n  }\n\n  Status convertStatus(Server s) {\n    switch (s.getStatus()) {\n    case 0:\n      return Status.SUCCESS;\n    case 1:\n      return Status.FAILURE;\n    case 2:\n      return Status.FAILURE;\n    default: // should not happen\n      return null;\n    }\n  }\n\n  String statusName(Server s) {\n    Status status = convertStatus(s);\n    return status.name();\n  }\n\n}\n")),Object(r.b)("p",null,"Assuming that the class ",Object(r.b)("inlineCode",{parentName:"p"},"lib.Server")," is part of a pre-compiled library, Infer\nwill report a null pointer exception in ",Object(r.b)("inlineCode",{parentName:"p"},"statusName"),". This happens whenever\n",Object(r.b)("inlineCode",{parentName:"p"},"s.getStatus()")," returns a value greater that ",Object(r.b)("inlineCode",{parentName:"p"},"3"),", in which case the default\nbranch of the switch statement is taken and ",Object(r.b)("inlineCode",{parentName:"p"},"convertStatus")," returns ",Object(r.b)("inlineCode",{parentName:"p"},"null"),".\nHowever, we know from the documentation that the method ",Object(r.b)("inlineCode",{parentName:"p"},"lib.Server.getStatus"),"\ncan only return ",Object(r.b)("inlineCode",{parentName:"p"},"0"),", ",Object(r.b)("inlineCode",{parentName:"p"},"1"),", or ",Object(r.b)("inlineCode",{parentName:"p"},"2"),". A possible approach would be to use an\nassertion like the Guava ",Object(r.b)("inlineCode",{parentName:"p"},"Preconditions.checkState")," to inform Infer about the\ninvariant:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"Status convertStatus(Server s) {\n  int serverStatus = s.getStatus();\n  Preconditions.checkState(serverStatus >= 0 && serverStatus < 3);\n  switch (s.getStatus()) {\n    ...\n  }\n}\n")),Object(r.b)("p",null,"However, in the case where adding preconditions is not possible, we can then\nwrite a model for ",Object(r.b)("inlineCode",{parentName:"p"},"getStatus()")," in order to make the analysis more precise."),Object(r.b)("p",null,"To create a model for ",Object(r.b)("inlineCode",{parentName:"p"},"getStatus()"),", we need to add a class with the name and\nthe same package as for the original method. In this example:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"create a file ",Object(r.b)("inlineCode",{parentName:"li"},"infer/models/java/src/infer/models/Server.java")," with the\nfollowing content:")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"package infer.models;\n\nimport com.facebook.infer.models.InferBuiltins;\nimport com.facebook.infer.models.InferUndefined;\n\npublic class Server {\n\n  public int getStatus() {\n    int status = InferUndefined.int_undefined();\n    InferBuiltins.assume(status >= 0 && status < 3);\n    return status;\n  }\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"recompile infer:"),Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"make -C infer\n"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"run the analysis again:"),Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"infer run -- javac Test.java\n")))),Object(r.b)("p",null,"Now it should no longer report a null pointer exception."))}d.isMDXComponent=!0},176:function(e,n,t){"use strict";t.d(n,"a",(function(){return l})),t.d(n,"b",(function(){return d}));var a=t(0),i=t.n(a),r=i.a.createContext({}),o=function(e){var n=i.a.useContext(r),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},l=function(e){var n=o(e.components);return i.a.createElement(r.Provider,{value:n},e.children)};var c="mdxType",s={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},b=Object(a.forwardRef)((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=function(e,n){var t={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===n.indexOf(a)&&(t[a]=e[a]);return t}(e,["components","mdxType","originalType","parentName"]),b=o(t),d=a,p=b[l+"."+d]||b[d]||s[d]||r;return t?i.a.createElement(p,Object.assign({},{ref:n},c,{components:t})):i.a.createElement(p,Object.assign({},{ref:n},c))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=b;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[c]="string"==typeof e?e:a,o[1]=l;for(var d=2;d<r;d++)o[d]=t[d];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"}}]);