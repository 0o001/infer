(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{143:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"rightToc",(function(){return c})),a.d(t,"metadata",(function(){return s})),a.d(t,"default",(function(){return p}));var n=a(1),r=a(9),o=(a(0),a(174)),i={id:"absint-framework",title:"Building checkers with the Infer.AI framework"},c=[{value:"By example: intraprocedural analysis",id:"by-example-intraprocedural-analysis",children:[]},{value:"Basic error reporting",id:"basic-error-reporting",children:[]},{value:"By example: interprocedural analysis",id:"by-example-interprocedural-analysis",children:[]},{value:"Relevant code",id:"relevant-code",children:[]},{value:"IR basics: SIL, CFG's, <code>tenv</code>'s, <code>procdesc</code>'s, and <code>procname</code>'s",id:"ir-basics-sil-cfgs-tenvs-procdescs-and-procnames",children:[]},{value:"Framework-specific IR: <code>ProcCFG</code>, <code>ProcData</code>, and <code>extras</code>",id:"framework-specific-ir-proccfg-procdata-and-extras",children:[]},{value:"How it works",id:"how-it-works",children:[]},{value:"Intro: abstract interpretation",id:"intro-abstract-interpretation",children:[]},{value:"How do I make an analysis compositional?",id:"how-do-i-make-an-analysis-compositional",children:[]}],s={id:"absint-framework",title:"Building checkers with the Infer.AI framework",description:"Infer.AI is a framework for quickly developing abstract interpretation-based",source:"@site/docs/04-absint-framework.md",permalink:"/docs/absint-framework",sidebar:"docs",previous:{title:"Linters bug types",permalink:"/docs/linters-bug-types"},next:{title:"Simple intraprocedural checkers",permalink:"/docs/adding-checkers"}},b={rightToc:c,metadata:s},l="wrapper";function p(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(o.b)(l,Object(n.a)({},b,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Infer.AI is a framework for quickly developing abstract interpretation-based\ncheckers (intraprocedural or interprocedural). You define only:"),Object(o.b)("p",null,"(1) An abstract domain (type of abstract state plus ",Object(o.b)("inlineCode",{parentName:"p"},"<="),", ",Object(o.b)("inlineCode",{parentName:"p"},"join"),", and ",Object(o.b)("inlineCode",{parentName:"p"},"widen"),"\noperations)"),Object(o.b)("p",null,"(2) Transfer functions (a transformer that takes an abstract state as input and\nproduces an abstract state as output)"),Object(o.b)("p",null,"and then you have an analysis that can run on all of the languages Infer\nsupports (C, Obj-C, C++, and Java)!"),Object(o.b)("p",null,"This guide covers how to use the framework. For background on why we built the\nframework and how it works, check out these\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://fbinfer.com/downloads/pldi17-infer-ai-tutorial.pdf"}),"slides")," from a PLDI\n2017 tutorial and this\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://atscaleconference.com/videos/getting-the-most-out-of-static-analyzers"}),"talk"),"\nfrom @Scale2016."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"If you feel like coding instead of reading, a great way to get started with\nInfer.AI is to go through the lab exercise\n",Object(o.b)("a",Object(n.a)({parentName:"strong"},{href:"https://github.com/facebook/infer/blob/master/infer/src/labs/lab.md"}),"here"),".")),Object(o.b)("h2",{id:"by-example-intraprocedural-analysis"},"By example: intraprocedural analysis"),Object(o.b)("p",null,"This section helps you get started ASAP if you already understand\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://www.di.ens.fr/~cousot/AI/IntroAbsInt.html"}),"abstract interpretation")," (or\ndon't, but are feeling bold)."),Object(o.b)("p",null,"Take a look at\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/checkers/liveness.ml"}),"liveness.ml"),".\nThis code is performing a compilers-101 style liveness analysis over\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"#ir-basics-sil-cfgs-tenvs-procdescs-and-procnames"}),"SIL"),", Infer's intermediate\nlanguage. Since this code is fairly small and you should already understand what\nit's trying to do, it's a fairly good place to look in order to understand both\nhow to use the abstract interpretation framework and what SIL is."),Object(o.b)("p",null,"There are basically three important bits here: defining the domain, defining the\ntransfer functions, and then passing the pieces to the framework to create an an\nanalysis. Let's break down the third bit:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"module Analyzer =\n  AbstractInterpreter.Make\n    (ProcCfg.Backward(ProcCfg.Exceptional))\n    (TransferFunctions)\n")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"ProcCfg.Backward(ProcCfg.Exceptional)"),' part says: "I want the direction of\niteration to be backward" (since liveness is a backward analysis), and "I want\nto the analysis to follow exceptional edges". For a forward analysis that\nignores exceptional edges, you would do ',Object(o.b)("inlineCode",{parentName:"p"},"ProcCfg.Normal")," instead (and many other\ncombinations are possible; take a look at\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/absint/ProcCfg.mli"}),"ProcCfg.mli"),"\nfor more). And finally, the ",Object(o.b)("inlineCode",{parentName:"p"},"TransferFunctions"),' part says "Use the transfer\nfunctions I defined above".'),Object(o.b)("p",null,"Now you have an ",Object(o.b)("inlineCode",{parentName:"p"},"Analyzer")," module that exposes useful functions like\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/absint/AbstractInterpreter.mli#L30"}),Object(o.b)("inlineCode",{parentName:"a"},"compute_post")),"\n(take a procedure as input and compute a postcondition) and\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/absint/AbstractInterpreter.mli#L36"}),Object(o.b)("inlineCode",{parentName:"a"},"exec_pdesc")),"\n(take a procedure and compute an invariant map from node id's to the pre/post at\neach node). The next step is to hook your checker up to the Infer CLI. For the\nliveness analysis, you would do this by exposing a function for running the\nchecker on a single procedure:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),'let checker { Callbacks.proc_desc; tenv; } =\n  match Analyzer.compute_post (ProcData.make_default proc_desc tenv) with\n  | Some post -> Logging.progress "Computed post %a for %a" Analyzer.Domain.pp post Typ.Procname.pp (Procdesc.get_proc_name proc_desc);\n  | None -> ()\n')),Object(o.b)("p",null,"and then adding ",Object(o.b)("inlineCode",{parentName:"p"},"Liveness.checker, checkers_enabled")," to the list of registered\ncheckers\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/checkers/registerCheckers.ml#L42"}),"here"),"."),Object(o.b)("p",null,"you can then run ",Object(o.b)("inlineCode",{parentName:"p"},"infer run -a checkers -- <your_build_command>")," to run your\nchecker on real code. See\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/analyzing-apps-or-projects"}),"here")," for more details\non the build systems supported by Infer."),Object(o.b)("p",null,"Other examples of simple intraprocedural checkers are\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/checkers/addressTaken.ml"}),"addressTaken.ml"),"\nand\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/checkers/copyPropagation.ml"}),"copyPropagation.ml"),"."),Object(o.b)("h2",{id:"basic-error-reporting"},"Basic error reporting"),Object(o.b)("p",null,"Useful analyses have output. Basic printing to stderr or stderr is good for\ndebugging, but to report a programmer-readable error that is tied to a source\ncode location, you'll want to use ",Object(o.b)("inlineCode",{parentName:"p"},"Reporting.log_error"),". Some examples of\nerror-logging code:\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/concurrency/RacerD.ml#L166"}),"1"),",\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/checkers/annotationReachability.ml#L224"}),"2"),",\nor\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/quandary/TaintAnalysis.ml#L186"}),"3"),"."),Object(o.b)("h2",{id:"by-example-interprocedural-analysis"},"By example: interprocedural analysis"),Object(o.b)("p",null,'Let\'s assume you have already read and understood the "intraprocedural analysis"\nsection and have an intraprocedural checker. The abstract interpretation\nframework makes it easy to convert your intraprocedural analysis into a\n',Object(o.b)("em",{parentName:"p"},"modular")," interprocedural analysis. Let me emphasize the ",Object(o.b)("em",{parentName:"p"},"modular")," point once\nmore; global analyses cannot be expressed in this framework."),Object(o.b)("p",null,"To make your checker interprocedural, you need to:"),Object(o.b)("p",null,"(1) Define the type of procedure summaries for your analysis and add some\nboilerplate for storing your data alongside the summaries for other analyses"),Object(o.b)("p",null,"(2) Add logic for (a) using summaries in your transfer functions and (b)\nconverting your intraprocedural abstract state to a summary."),Object(o.b)("p",null,"A good example to look at here is\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/checkers/Siof.ml"}),"siof.ml"),".\nStep (1) is just:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"module Summary = Summary.Make (struct\n    type summary = SiofDomain.astate\n\n    let update_payload astate payload =\n      { payload with Specs.siof = Some astate }\n\n    let read_from_payload payload =\n      payload.Specs.siof\n  end)\n")),Object(o.b)("p",null,"along with adding the ",Object(o.b)("inlineCode",{parentName:"p"},"Specs.siof"),"\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/backend/specs.ml#L329"}),"field"),"\nto the ",Object(o.b)("inlineCode",{parentName:"p"},"Specs.payload")," record\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/backend/specs.ml#L321"}),"type"),".\nHere, the type of the abstract state and the type of the summary are the same,\nwhich makes things easier for us (no logic to convert an abstract state to a\nsummary)."),Object(o.b)("p",null,"Part (2a) is\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/checkers/Siof.ml#L65"}),"here"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"match Summary.read_summary pdesc callee_pname with\n")),Object(o.b)("p",null,'This says: "read the summary for ',Object(o.b)("inlineCode",{parentName:"p"},"callee_pname")," from procedure ",Object(o.b)("inlineCode",{parentName:"p"},"pdesc")," with type\nenvironment ",Object(o.b)("inlineCode",{parentName:"p"},"tenv"),'". You must then add logic for applying the summary to the\ncurrent abstract state (often, this is as simple as doing a join).'),Object(o.b)("p",null,"Because our summary type is the same as the abstract state, part (2b) can be\ndone for us by making use of the convenient\n",Object(o.b)("inlineCode",{parentName:"p"},"AbstractInterpreter.Interprocedural"),"\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/absint/AbstractInterpreter.mli#L19"}),"functor"),"\n(for an example of what to do when the types are different, take a look at\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/quandary/TaintAnalysis.ml#L540"}),"Quandary"),"):"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"module Interprocedural = Analyzer.Interprocedural (Summary)\n")),Object(o.b)("p",null,"This ",Object(o.b)("inlineCode",{parentName:"p"},"Interprocedural")," module will automatically do the work of computing and\nstoring the summary for us. All we need to do is change the exposed ",Object(o.b)("inlineCode",{parentName:"p"},"checker"),"\nfunction registered in ",Object(o.b)("inlineCode",{parentName:"p"},"registerCheckers.ml")," to call ",Object(o.b)("inlineCode",{parentName:"p"},"Interprocedural.checker"),"\ninstead:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"let checker callback =\n  ignore(Interprocedural.checker callback ProcData.empty_extras in)\n")),Object(o.b)("p",null,"That's it! We now have an interprocedural analysis."),Object(o.b)("p",null,"One very important note here: a current (and soon-to-be-lifted) limitation\nprevents us from running multiple interprocedural checkers at the same time. If\nyou register an interprocedural checker, be sure to unregister the other other\nones. Otherwise, there's a risk that the checkers will clobber each other's\nresults."),Object(o.b)("h2",{id:"relevant-code"},"Relevant code"),Object(o.b)("p",null,"Some pointers to useful code for building new analyses, and to the\nimplementation of the framework for the interested:"),Object(o.b)("p",null,"Domain combinators:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"AbstractDomain.BottomLifted"),", ",Object(o.b)("inlineCode",{parentName:"li"},"AbstractDomain.FiniteSet"),",\n",Object(o.b)("inlineCode",{parentName:"li"},"AbstractDomain.Map"),", ",Object(o.b)("inlineCode",{parentName:"li"},"AbstractDomain.Pair")," (all in\n",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/facebook/infer/blob/master/infer/src/checkers/AbstractDomain.mli"}),"AbstractDomain"),")")),Object(o.b)("p",null,"Domains and domain building blocks:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/facebook/infer/blob/master/infer/src/checkers/accessPath.mli"}),"AccessPath")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/facebook/infer/blob/master/infer/src/checkers/accessPathDomains.mli"}),"AccessPathDomains")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/facebook/infer/blob/master/infer/src/checkers/accessTree.ml"}),"AccessTree"))),Object(o.b)("p",null,"Reporting errors with interprocedural traces:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Examples:\n",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/facebook/infer/blob/master/infer/src/checkers/SiofTrace.ml"}),Object(o.b)("inlineCode",{parentName:"a"},"SiofTrace.ml")),",\n",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/facebook/infer/blob/master/infer/src/quandary/JavaTrace.ml"}),Object(o.b)("inlineCode",{parentName:"a"},"JavaTrace.ml")),",\n",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/facebook/infer/blob/master/infer/src/quandary/CppTrace.ml"}),Object(o.b)("inlineCode",{parentName:"a"},"CppTrace.ml")),"."),Object(o.b)("li",{parentName:"ul"},"Implementation:\n",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/facebook/infer/blob/master/infer/src/checkers/Trace.mli"}),Object(o.b)("inlineCode",{parentName:"a"},"Trace")))),Object(o.b)("p",null,"Implementation:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/facebook/infer/blob/master/infer/src/absint/AbstractDomain.ml"}),Object(o.b)("inlineCode",{parentName:"a"},"AbstractDomain"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/facebook/infer/blob/master/infer/src/absint/AbstractInterpreter.mli"}),Object(o.b)("inlineCode",{parentName:"a"},"TransferFunctions"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/facebook/infer/blob/master/infer/src/absint/AbstractInterpreter.mli"}),Object(o.b)("inlineCode",{parentName:"a"},"AbstractInterpreter"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/facebook/infer/blob/master/infer/src/absint/ProcCfg.mli"}),Object(o.b)("inlineCode",{parentName:"a"},"ProcCFG"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/facebook/infer/blob/master/infer/src/absint/Summary.ml"}),Object(o.b)("inlineCode",{parentName:"a"},"Summary"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/facebook/infer/blob/master/infer/src/absint/Scheduler.ml"}),Object(o.b)("inlineCode",{parentName:"a"},"Scheduler")))),Object(o.b)("h2",{id:"ir-basics-sil-cfgs-tenvs-procdescs-and-procnames"},"IR basics: SIL, CFG's, ",Object(o.b)("inlineCode",{parentName:"h2"},"tenv"),"'s, ",Object(o.b)("inlineCode",{parentName:"h2"},"procdesc"),"'s, and ",Object(o.b)("inlineCode",{parentName:"h2"},"procname"),"'s"),Object(o.b)("p",null,"All of the languages analyzed by Infer are converted into a common intermediate\nrepresentation. A program is represented as a control-flow graph\n(",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/IR/Cfg.rei"}),"CFG"),")\nwhose nodes contain lists of instructions in the SIL language. SIL is a small\nlow-level language that has some similarities with C, LLVM\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://llvm.org/docs/LangRef.html"}),"IR"),", and\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://research.microsoft.com/en-us/um/people/leino/papers/krml178.pdf"}),"Boogie"),"."),Object(o.b)("p",null,Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/IR/Exp.rei#L25"}),"Expressions"),"\nare literals, program variables (",Object(o.b)("inlineCode",{parentName:"p"},"Pvar"),"'s), temporary variables (",Object(o.b)("inlineCode",{parentName:"p"},"Ident"),"'s), a\nfield offset from a struct (OO features like objects are lowered into struct's),\nor an index offset from an array."),Object(o.b)("p",null,"There are four interesting kinds of\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/IR/Sil.rei#L38"}),"instructions"),":\n",Object(o.b)("inlineCode",{parentName:"p"},"Load")," for reading into a temporary variable, ",Object(o.b)("inlineCode",{parentName:"p"},"Store")," for writing to a program\nvariable, field of a struct, or an array, ",Object(o.b)("inlineCode",{parentName:"p"},"Prune e")," (often called ",Object(o.b)("inlineCode",{parentName:"p"},"assume")," in\nother PL formalisms) blocks execution unless the expression ",Object(o.b)("inlineCode",{parentName:"p"},"e")," evaluates to\ntrue, and ",Object(o.b)("inlineCode",{parentName:"p"},"Call")," represents function calls."),Object(o.b)("p",null,"Instructions and expressions have\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/IR/Typ.rei#L76"}),"types"),".\nA ",Object(o.b)("inlineCode",{parentName:"p"},"Tstruct")," (think: object) type has a\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/IR/Typename.rei#L13"}),Object(o.b)("inlineCode",{parentName:"a"},"Typename")),",\nand it is often useful to look up metadata about the type (what fields does it\nhave, what methods does it declare, what is its superclass, etc.) in the type\nenvironment, or\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/IR/Tenv.rei#L37"}),Object(o.b)("inlineCode",{parentName:"a"},"tenv")),"."),Object(o.b)("p",null,"A procedure description or\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/IR/Procdesc.rei"}),Object(o.b)("inlineCode",{parentName:"a"},"procdesc")),"\n(sometimes abbreviated ",Object(o.b)("inlineCode",{parentName:"p"},"pdesc"),") is an abstraction of a procedure declaration: it\nstores the CFG of the procedure, its signature, its annotations, and so on."),Object(o.b)("p",null,"A procedure name or\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/IR/Procname.rei"}),Object(o.b)("inlineCode",{parentName:"a"},"procname")),"\n(sometimes abbreviated ",Object(o.b)("inlineCode",{parentName:"p"},"pname"),") is an abstraction of a called procedure name.\nOne procname may correspond to multiple (or zero) ",Object(o.b)("inlineCode",{parentName:"p"},"procdesc"),"'s after resolution."),Object(o.b)("h2",{id:"framework-specific-ir-proccfg-procdata-and-extras"},"Framework-specific IR: ",Object(o.b)("inlineCode",{parentName:"h2"},"ProcCFG"),", ",Object(o.b)("inlineCode",{parentName:"h2"},"ProcData"),", and ",Object(o.b)("inlineCode",{parentName:"h2"},"extras")),Object(o.b)("p",null,"The abstract interpretation framework has a few additional constructs that are\nworth explaining."),Object(o.b)("p",null,"A\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/absint/procCfg.mli"}),Object(o.b)("inlineCode",{parentName:"a"},"ProcCfG")),"\nrepresents the CFG of a ",Object(o.b)("em",{parentName:"p"},"single")," procedure whereas (perhaps confusingly) a\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/IR/Cfg.rei"}),Object(o.b)("inlineCode",{parentName:"a"},"Cfg"))," is\nthe CFG for an entire file. A ",Object(o.b)("inlineCode",{parentName:"p"},"ProcCfg")," is really a customizable view of the\nunderlying procedure CFG; we can get a view the CFG with its edges backward\n(",Object(o.b)("inlineCode",{parentName:"p"},"ProcCfg.Backward"),"), with or without exceptional edges (",Object(o.b)("inlineCode",{parentName:"p"},"Normal"),"/",Object(o.b)("inlineCode",{parentName:"p"},"Exceptional"),",\nrespectively), or with each node holding at most one instruction\n(",Object(o.b)("inlineCode",{parentName:"p"},"OneInstrPerNode"),")."),Object(o.b)("p",null,Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/absint/procData.mli"}),Object(o.b)("inlineCode",{parentName:"a"},"ProcData")),"\nis a container that holds all of the read-only information required to analyze a\nsingle procedure: procedure description, and ",Object(o.b)("inlineCode",{parentName:"p"},"extras"),". The ",Object(o.b)("inlineCode",{parentName:"p"},"extras")," are custom\nread-only data that are computed before analysis begins, and can be accessed\nfrom the transfer functions. Most often, no extras are required for analysis\n(",Object(o.b)("inlineCode",{parentName:"p"},"ProcData.empty_extras"),"), but it can be useful to stash information like a map\nfrom a formal to its\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/quandary/TaintAnalysis.ml#L88"}),"index"),"\nor an invariant\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/backend/preanal.ml#L115"}),"map"),"\nfrom a prior analysis in the extras."),Object(o.b)("h2",{id:"how-it-works"},"How it works"),Object(o.b)("p",null,"Coming soon."),Object(o.b)("h2",{id:"intro-abstract-interpretation"},"Intro: abstract interpretation"),Object(o.b)("p",null,"Coming soon."),Object(o.b)("h2",{id:"how-do-i-make-an-analysis-compositional"},"How do I make an analysis compositional?"),Object(o.b)("p",null,"Coming soon."))}p.isMDXComponent=!0},174:function(e,t,a){"use strict";a.d(t,"a",(function(){return c})),a.d(t,"b",(function(){return p}));var n=a(0),r=a.n(n),o=r.a.createContext({}),i=function(e){var t=r.a.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):Object.assign({},t,e)),a},c=function(e){var t=i(e.components);return r.a.createElement(o.Provider,{value:t},e.children)};var s="mdxType",b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},l=Object(n.forwardRef)((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,c=e.parentName,s=function(e,t){var a={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&-1===t.indexOf(n)&&(a[n]=e[n]);return a}(e,["components","mdxType","originalType","parentName"]),l=i(a),p=n,m=l[c+"."+p]||l[p]||b[p]||o;return a?r.a.createElement(m,Object.assign({},{ref:t},s,{components:a})):r.a.createElement(m,Object.assign({},{ref:t},s))}));function p(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=l;var c={};for(var b in t)hasOwnProperty.call(t,b)&&(c[b]=t[b]);c.originalType=e,c[s]="string"==typeof e?e:n,i[1]=c;for(var p=2;p<o;p++)i[p]=a[p];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,a)}l.displayName="MDXCreateElement"}}]);